import logging
from django.db import transaction
from decimal import Decimal
from pydantic import ValidationError

from algo.models import Deal, Order, StoreClient, AdminSystemConfig, Market
from algo.enums import OrderType
from providers.schemas.wallex_schemas  import OrderResponseSchema, OrderResultSchema
from providers.provider_factory import ProviderFactory

logger = logging.getLogger(__name__)


class DealProcessor:
    """
    Processes unprocessed deals generated by trading strategies, places orders
    on the respective exchanges, and updates deal status.
    """

    def process_unprocessed_deals(self):
        """
        Reads unprocessed and active deals from the database and dispatches them
        for order placement.
        """
        # Fetch only deals that are not yet processed and are active
        unprocessed_deals = Deal.objects.filter(is_processed=False, is_active=True)

        if not unprocessed_deals.exists():
            logger.info("No new deals found to process.")
            return

        logger.info(f"Found {unprocessed_deals.count()} unprocessed deals to process.")
        for deal in unprocessed_deals:
            try:
                self._place_order_for_deal(deal)
            except Exception as e:
                logger.error(f"Error processing deal {deal.client_deal_id}: {e}", exc_info=True)
                # Optionally, update deal status to indicate an error or retry
                # deal.status = StrategyState.ERROR.value # You might need to define an ERROR state in StrategyState
                # deal.save()

    def _place_order_for_deal(self, deal: Deal):
        """
        Places an order on the exchange for a single deal.
        """
        logger.info(f"Attempting to place order for deal {deal.client_deal_id} ({deal.market_symbol} {deal.side}).")

        # 1. Retrieve StoreClient for the deal's provider
        store_client = StoreClient.objects.filter(provider=deal.provider_name).first()
        if not store_client:
            logger.error(
                f"No StoreClient found for provider: {deal.provider_name}. Cannot process deal {deal.client_deal_id}.")
            return

        # 2. Get provider instance from factory
        try:
            provider_instance = ProviderFactory.create_provider(
                provider_name=deal.provider_name,
                provider_config={}  # Pass any necessary provider-specific config here
            )
        except ValueError as e:
            logger.error(f"Failed to create provider instance for {deal.provider_name}: {e}")
            return

        # 3. Retrieve AdminSystemConfig for order amount and other settings
        admin_config = AdminSystemConfig.get_instance()
        order_amount_tether = Decimal(str(admin_config.wallex_tether_order_amount))  # Use Decimal for precision

        # 4. Retrieve Market information for adjustments
        try:
            market_instance = Market.objects.get(symbol=deal.market_symbol, provider=deal.provider_name)
        except Market.DoesNotExist:
            logger.error(
                f"Market {deal.market_symbol} not found for provider {deal.provider_name}. Cannot place order for deal {deal.client_deal_id}.")
            return

        # Calculate quantity based on desired order amount and current price
        if deal.price and deal.price > 0:
            calculated_quantity = deal.quantity if deal.quantity else (order_amount_tether / deal.price)
        else:
            logger.error(
                f"Deal price is invalid ({deal.price}). Cannot calculate quantity for deal {deal.client_deal_id}.")
            return

        # Adjust quantity and price based on market rules
        adjusted_quantity = Decimal(
            str(market_instance.adjust_quantity(float(calculated_quantity))))  # Convert back to Decimal
        adjusted_price = Decimal(str(market_instance.adjust_price(float(deal.price))))  # Convert back to Decimal

        # Ensure adjusted quantity meets minimums
        adjusted_quantity = Decimal(str(market_instance.adjust_min_qty(float(adjusted_quantity))))

        # Prepare order request data for the provider
        order_request_data = {
            "symbol": deal.market_symbol,
            "type": OrderType.LIMIT.value,  # Use .value for enum
            "side": deal.side,
            "price": adjusted_price,
            "quantity": adjusted_quantity,
        }

        # 5. Call provider's create_order API
        try:
            # The create_order method in providers should now return OrderResponseSchema
            api_response: OrderResponseSchema = provider_instance.create_order(
                api_key=store_client.api_key,
                order_request_schema=order_request_data
            )

            if api_response.success and api_response.result:
                order_result: OrderResultSchema = api_response.result

                with transaction.atomic():
                    # Create an Order record in your database
                    order = Order.objects.create(
                        deal=deal,
                        store_client=store_client,
                        symbol=order_result.symbol,
                        type=order_result.type,
                        side=order_result.side,
                        price=Decimal(order_result.price) if order_result.price is not None else None,
                        quantity=Decimal(order_result.orig_qty) if order_result.orig_qty is not None else None,
                        orig_qty=Decimal(order_result.orig_qty) if order_result.orig_qty is not None else None,
                        orig_sum=Decimal(order_result.orig_sum) if order_result.orig_sum is not None else None,
                        executed_price=Decimal(
                            order_result.executed_price) if order_result.executed_price is not None else None,
                        executed_qty=Decimal(
                            order_result.executed_qty) if order_result.executed_qty is not None else None,
                        executed_sum=Decimal(
                            order_result.executed_sum) if order_result.executed_sum is not None else None,
                        executed_percent=order_result.executed_percent,
                        status=order_result.status,
                        active=order_result.active,
                        client_order_id=order_result.client_order_id,
                        timestamp_created_at=order_result.timestamp_created_at,
                    )
                    logger.info(f"Order {order.client_order_id} created successfully for deal {deal.client_deal_id}.")

                    # Update the deal to mark it as processed and update its status
                    deal.is_processed = True
                    # You might want to update deal.status to reflect order placement, e.g., StrategyState.ORDER_PLACED
                    # Ensure StrategyState has a suitable state like 'ORDER_PLACED' or 'ORDERING'
                    deal.save(update_fields=['is_processed'])
            else:
                logger.error(f"Failed to create order for deal {deal.client_deal_id}. Message: {api_response.message}")
                # Optionally, update deal status to indicate failure
                # deal.status = StrategyState.ORDER_FAILED.value
                # deal.save()

        except ValidationError as e:  # Pydantic ValidationError
            logger.error(f"Pydantic validation error for API response for deal {deal.client_deal_id}: {e.errors()}",
                         exc_info=True)
        except Exception as e:
            logger.error(f"Unexpected error during order creation for deal {deal.client_deal_id}: {e}", exc_info=True)

