import logging
from django.db import transaction
from decimal import Decimal

from algo.models import Deal, Order, StoreClient, AdminSystemConfig, Market
from providers.provider_factory import ProviderFactory
from algo.enums import OrderType
from providers.schemas.wallex_schemas import OrderResponseSchema, \
    OrderResultSchema  # Assuming this schema is consistent for all providers
from pydantic import ValidationError  # Import ValidationError for handling pydantic errors

logger = logging.getLogger(__name__)


class DealProcessor:
    """
    Processes unprocessed deals generated by trading strategies, places orders
    on the respective exchanges, and updates deal status.
    """

    def process_unprocessed_deals(self):
        """
        Reads unprocessed and active deals from the database and dispatches them
        for order placement.
        """
        # Fetch only deals that are not yet processed and are active
        unprocessed_deals = Deal.objects.filter(is_processed=False, is_active=True)

        if not unprocessed_deals.exists():
            logger.info("No new deals found to process.")
            return

        logger.info(f"Found {unprocessed_deals.count()} unprocessed deals to process.")
        for deal in unprocessed_deals:
            try:
                self._place_order_for_deal(deal)
            except Exception as e:
                logger.error(f"Error processing deal {deal.client_deal_id}: {e}", exc_info=True)
                # Optionally, update deal status to indicate an error or retry
                # deal.status = StrategyState.ERROR # You might need to define an ERROR state
                # deal.save()

    def _place_order_for_deal(self, deal: Deal):
        """
        Places an order on the exchange for a single deal.
        """
        logger.info(f"Attempting to place order for deal {deal.client_deal_id} ({deal.market_symbol} {deal.side}).")

        # 1. Retrieve StoreClient for the deal's provider
        store_client = StoreClient.objects.filter(provider=deal.provider_name).first()
        if not store_client:
            logger.error(
                f"No StoreClient found for provider: {deal.provider_name}. Cannot process deal {deal.client_deal_id}.")
            return

        # 2. Get provider instance from factory
        try:
            provider_instance = ProviderFactory.create_provider(
                provider_name=deal.provider_name,
                provider_config={}  # Pass any necessary provider-specific config here
            )
        except ValueError as e:
            logger.error(f"Failed to create provider instance for {deal.provider_name}: {e}")
            return

        # 3. Retrieve AdminSystemConfig for order amount and other settings
        admin_config = AdminSystemConfig.get_instance()
        order_amount_tether = Decimal(admin_config.wallex_tether_order_amount)  # Use Decimal for precision

        # 4. Retrieve Market information for adjustments
        try:
            market_instance = Market.objects.get(symbol=deal.market_symbol, provider=deal.provider_name)
        except Market.DoesNotExist:
            logger.error(
                f"Market {deal.market_symbol} not found for provider {deal.provider_name}. Cannot place order for deal {deal.client_deal_id}.")
            return

        # Calculate quantity based on desired order amount and current price
        # Ensure price is not zero to avoid division by zero
        if deal.price and deal.price > 0:
            # Calculate base quantity (e.g., BTC quantity for BTC/USDT)
            # If deal.side is BUY, we are buying base_asset with quote_asset (USDT)
            # quantity = order_amount_tether / deal.price
            # If deal.side is SELL, we are selling base_asset to get quote_asset (USDT)
            # For simplicity, let's assume order_amount_tether is in quote currency (USDT)
            # and we want to trade a quantity of base asset equivalent to this USDT value.
            # This logic might need refinement based on your exact strategy's quantity calculation.

            # For now, let's assume `deal.quantity` is the desired quantity of the base asset,
            # and `order_amount_tether` is a budget for buy orders or target for sell orders.
            # If `deal.quantity` is null, calculate it based on `order_amount_tether`

            calculated_quantity = deal.quantity if deal.quantity else (order_amount_tether / deal.price)
        else:
            logger.error(
                f"Deal price is invalid ({deal.price}). Cannot calculate quantity for deal {deal.client_deal_id}.")
            return

        # Adjust quantity and price based on market rules
        adjusted_quantity = Decimal(
            str(market_instance.adjust_quantity(float(calculated_quantity))))  # Convert back to Decimal
        adjusted_price = Decimal(str(market_instance.adjust_price(float(deal.price))))  # Convert back to Decimal

        # Ensure adjusted quantity meets minimums
        adjusted_quantity = Decimal(str(market_instance.adjust_min_qty(float(adjusted_quantity))))

        # Prepare order request data, ensuring Decimal values are converted to string for API if required by Pydantic schema
        # Pydantic condecimal handles Decimal objects directly, so float() conversion here is okay for Pydantic but
        # the API might expect strings. Let's send as Decimal if Pydantic allows, otherwise as string.
        order_request_data = {
            "symbol": deal.market_symbol,
            "type": OrderType.LIMIT,  # Assuming LIMIT orders for strategy
            "side": deal.side,
            "price": adjusted_price,  # Pass Decimal directly
            "quantity": adjusted_quantity,  # Pass Decimal directly
        }

        # 5. Call provider's create_order API
        try:
            # The create_order method in providers should return OrderResponseSchema
            # or a dict that can be validated by it.
            api_response: OrderResponseSchema = provider_instance.create_order(
                api_key=store_client.api_key,
                order_request_data=order_request_data  # Pass dict
            ) #todo: expected: OrderResponseSchema but get dict

            if api_response.success:
                with transaction.atomic():
                    order_result: OrderResultSchema = api_response.result  # Access the Pydantic result object
                    #todo: create by related provider name schemas i mean for nobitex use its pydantic schema and for wallex its related schema use clean and stractural solid to handel this scable by all provider
                    # Create an Order record in your database
                    order = Order.objects.create(
                        deal=deal,
                        store_client=store_client,
                        symbol=order_result.symbol,
                        type=order_result.type,
                        side=order_result.side,
                        price=Decimal(order_result.price) if order_result.price else None,
                        quantity=Decimal(order_result.orig_qty) if order_result.orig_qty else None,
                        orig_qty=Decimal(order_result.orig_qty) if order_result.orig_qty else None,
                        orig_sum=Decimal(order_result.orig_sum) if order_result.orig_sum else None,
                        executed_price=Decimal(order_result.executed_price) if order_result.executed_price else None,
                        executed_qty=Decimal(order_result.executed_qty) if order_result.executed_qty else None,
                        executed_sum=Decimal(order_result.executed_sum) if order_result.executed_sum else None,
                        executed_percent=order_result.executed_percent,
                        status=order_result.status,
                        active=order_result.active,
                        client_order_id=order_result.client_order_id,
                        timestamp_created_at=order_result.timestamp_created_at,
                    )
                    logger.info(f"Order {order.client_order_id} created successfully for deal {deal.client_deal_id}.")

                    # Update the deal to mark it as processed and update its status
                    deal.is_processed = True
                    # You might want to update deal.status to reflect order placement, e.g., StrategyState.ORDER_PLACED
                    # Ensure StrategyState has a suitable state like 'ORDER_PLACED' or 'ORDERING'
                    deal.save(update_fields=['is_processed'])  # Only update processed field
            else:
                logger.error(f"Failed to create order for deal {deal.client_deal_id}. Message: {api_response.message}")
                # Optionally, update deal status to indicate failure
                # deal.status = StrategyState.ORDER_FAILED
                # deal.save()

        except ValidationError as e:
            logger.error(f"Pydantic validation error for API response for deal {deal.client_deal_id}: {e.errors()}",
                         exc_info=True)
        except Exception as e:
            logger.error(f"Unexpected error during order creation for deal {deal.client_deal_id}: {e}", exc_info=True)

