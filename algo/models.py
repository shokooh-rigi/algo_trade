import uuid
import logging
from django.core.exceptions import ValidationError
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db import models, transaction
from decimal import Decimal
from django.db.models import CASCADE
from django.utils.translation import gettext_lazy as _
from pydantic import ValidationError as PydanticValidationError

from algo.enums import OrderType, OrderSide, OrderStatus, DesiredBalanceAsset, ResolutionEnum
from algo.strategies.enums import StrategyState, ProcessedSideEnum, StrategyEnum
from algo_trade.base_manager import SoftDeleteManager
from algo_trade.base_model import BaseModel, SoftDeleteModel
from providers.providers_enum import ProviderEnum

logger = logging.getLogger(__name__)


class Deal(BaseModel):
    """
    Represents a trading opportunity generated by a strategy.
    It tracks the deal's lifecycle from creation to completion.
    """
    # Unique identifier for the deal
    client_deal_id = models.UUIDField(
        default=uuid.uuid4,
        editable=False,
        unique=True,
        help_text="A unique identifier for the deal."
    )

    # Strategy and Market information
    strategy_name = models.CharField(
        max_length=100,
        help_text="The name of the strategy that generated this deal."
    )
    provider_name = models.CharField(
        max_length=50,
        help_text="The name of the provider (e.g., WALLEX)."
    )
    market_symbol = models.CharField(
        max_length=20,
        help_text="The trading pair symbol (e.g., BTCUSDT)."
    )

    # Deal details
    side = models.CharField(
        max_length=5,
        choices=OrderSide.CHOICES, # Assuming OrderSide is still a class with CHOICES attribute
        help_text="The side of the deal (BUY or SELL)."
    )
    price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The price at which the deal was initiated."
    )
    quantity = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The quantity of the base asset to be traded."
    )

    # State management
    is_active = models.BooleanField(
        default=True,
        help_text="Whether the deal is currently active and should be processed."
    )
    status = models.CharField(
        max_length=20,
        choices=StrategyState.choices(), # CORRECTED: Call the choices() method
        default=StrategyState.STARTED.value,
        help_text="The current state of the deal lifecycle."
    )
    is_processed = models.BooleanField(
        default=False,
        help_text="Indicates if a related order has been placed for this deal."
    )
    processed_side = models.CharField(
        max_length=35,
        choices=ProcessedSideEnum.choices(),
        default=ProcessedSideEnum.NONE.value
    )
    # Tracking related orders
    # This can be a one-to-one or one-to-many relationship depending on your strategy
    # For a simple buy/sell strategy, one-to-many is better.
    # orders = models.ManyToManyField('Order', related_name='deals')
    # A cleaner approach is to use the `related_name` in the Order model's ForeignKey
    # to implicitly link them.

    def __str__(self):
        return f"Deal for {self.market_symbol} - {self.side} ({self.status})"


class Order(BaseModel):
    store_client = models.ForeignKey(
        'StoreClient',
        on_delete=models.SET_NULL,
        default=None,
        null=True,
        blank=True,
        related_name='orders',
    )
    deal = models.ForeignKey(
        to=Deal,
        on_delete=models.SET_NULL,
        default=None,
        related_name="orders",
        null=True,
        blank=True,
    )
    symbol = models.CharField(
        max_length=20,
        help_text="The trading pair symbol (e.g., BTCUSDT)."
    )
    type = models.CharField(
        max_length=10,
        choices=OrderType.CHOICES,
        help_text="The type of order (e.g., LIMIT or MARKET)."
    )
    side = models.CharField(
        max_length=5,
        choices=OrderSide.CHOICES,
        help_text="The side of the order (BUY or SELL)."
    )
    price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The price at which the order should be executed."
    )
    quantity = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The quantity of the asset to be traded."
    )
    orig_qty = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The original quantity as a string."
    )
    orig_sum = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The original sum as a string."
    )
    executed_price = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The executed price as a string."
    )
    executed_qty = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The executed quantity as a string."
    )
    executed_sum = models.DecimalField(
        max_digits=20,
        decimal_places=8,
        null=True,
        blank=True,
        help_text="The executed sum as a string."
    )
    executed_percent = models.IntegerField(
        null=True,
        blank=True,
        help_text="The percentage of the order that has been executed."
    )
    status = models.CharField(
        max_length=20,
        choices=OrderStatus.CHOICES,
        default=OrderStatus.NEW,
        help_text="The status of the order (e.g., NEW, FILLED, CANCELED)."
    )
    active = models.BooleanField(
        null=True,
        blank=True,
        help_text="Whether the order is active."
    )
    client_order_id = models.CharField(
        max_length=100,
        unique=True,
        null=True,
        blank=True,
        help_text="The client order ID."
    )
    timestamp_created_at = models.CharField(
        null=True,
        blank=True,
        max_length=100,
        help_text="The timestamp when the order was created."
    )
    should_cancel = models.BooleanField(
        default=False,
        help_text="Flag to indicate if the order should be canceled."
    )

    def __str__(self):
        return f"Order {self.client_order_id} ({self.symbol}) - {self.status}"


class StoreClient(SoftDeleteModel, BaseModel):
    """
    Represents a client in the system who is associated with a specific provider.

    Attributes:
        api_key (str): The API key for authenticating the client.
        api_secret (str): The optional API secret for the client.
        user_id (UUID): A unique identifier for the client, automatically generated.
        title (str): An optional descriptive title for the client.
        provider (str): The type of provider (e.g., WALLEX), selected from ProviderEnum choices.
    """
    name = models.CharField(
        max_length=100,
        unique=True,
        default=None,
        help_text="The name of the client."
    )
    api_key = models.CharField(
        max_length=150,
        unique=True,
        help_text="The API key for this client.",
    )
    api_secret = models.CharField(
        max_length=150,
        null=True,
        blank=True,
        help_text="The API secret for this client.",
    )
    user_id = models.UUIDField(
        unique=True,
        default=uuid.uuid4,  # Automatically generate a UUID for new instances
        editable=False,  # Prevent manual editing of this field
        help_text="A unique identifier for the client, automatically generated.",
    )
    title = models.CharField(
        max_length=250,
        blank=True,
        null=True,
        help_text="An optional descriptive title for this client.",
    )
    provider = models.CharField(
        max_length=50,
        choices=[(provider.value, provider.name) for provider in ProviderEnum],
        default=ProviderEnum.WALLEX.value,
        help_text="The provider type for this client.",
    )

    def __str__(self):
        return f"StoreClient {self.name} for provider {self.provider}"

    @classmethod
    def get_api_keys_by_provider(cls, provider: str) -> str:
        """
        Retrieve all API keys for clients associated with a specific provider.

        Args:
            provider (str): The provider type (e.g., WALLEX).

        Returns:
            list: A list of API keys for the specified provider.

        Raises:
            ValueError: If no API keys are found for the given provider.
        """
        try:
            api_key = cls.objects.filter(
                provider=provider
            ).values_list(
                'api_key',
                flat=True
            ).first()
            if not api_key:
                raise ValueError(f"No API keys found for provider: {provider}")
            return ""
        except Exception as e:
            logger.error(f"Error retrieving API keys for provider {provider}: {e}")
            return ''


class Asset(BaseModel):
    """
    Represent an asset in the system.
    """
    provider = models.CharField(
        max_length=50,
        choices=[(provider.value, provider.name) for provider in ProviderEnum],
        default=ProviderEnum.WALLEX.value,
        help_text="The provider type for this client.",
    )
    name = models.CharField(
        max_length=20,
        unique=True,
        help_text="The asset name (e.g., BTC, USDT)."
    )

    def __str__(self):
        return f"{self.name}"

    class Meta:
        verbose_name = "Asset"
        verbose_name_plural = "Assets"
        ordering = ["name"]


class AccountBalance(BaseModel):
    """
    Represents the balance of a StoreClient for a specific market and asset.

    Attributes:
        store_client (ForeignKey): The StoreClient associated with this balance.
        asset (ForeignKey): The asset (e.g., BTC, USDT).
        total_balance (Decimal): The total balance (available + locked).
        unbalance_threshold (int): Percentage threshold for balance alerts (1-99%).
    """
    store_client = models.ForeignKey(
        'StoreClient',
        on_delete=models.CASCADE,
        related_name='balances',
        help_text="The StoreClient associated with this balance."
    )
    asset = models.ForeignKey(
        'Asset',
        on_delete=models.CASCADE,
        related_name='balances',
        help_text="The asset name (e.g., BTC, USDT).",
    )
    total_balance = models.DecimalField(
        max_digits=20,
        decimal_places=6,
        default=0,
        help_text="The total balance (available + locked)."
    )
    unbalance_threshold = models.IntegerField(
        default=1,
        validators=[
            MinValueValidator(1, message="Value must be greater than 0."),
            MaxValueValidator(99, message="Value must be less than 100."),
        ],
        help_text="Percentage threshold (1-99%) for balance alerts."
    )
    def __str__(self):
        return f"Balance for {self.store_client.name} - {self.asset}"

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=['store_client', 'asset'],
                name='unique_store_client_asset'
            )
        ]

    def clean(self):
        """Validate unbalance_threshold is between 1-99%"""
        if not 1 <= self.unbalance_threshold <= 99:
            raise ValidationError("Unbalance threshold must be between 1 and 99")


class Market(models.Model):
    """
    Model to store market information from API.
    """
    provider = models.CharField(
        max_length=50,
        choices=[(provider.value, provider.name) for provider in ProviderEnum],
        default=ProviderEnum.WALLEX.value,
        help_text="The provider type for this client.",
    )
    symbol = models.CharField(
        default="Unknown",
        max_length=50,
        unique=True,
        help_text="The trading pair symbol (e.g., 'BTCUSDT')."
    )
    base_asset = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        help_text="The base asset of the market (e.g., 'BTC')."
    )
    base_asset_precision = models.IntegerField(
        null=True,
        blank=True,
        help_text="The decimal precision of the base asset."
    )
    quote_asset = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        help_text="The quote asset of the market (e.g., 'USDT')."
    )
    quote_precision = models.IntegerField(
        null=True,
        blank=True,
        help_text="The decimal precision of the quote asset."
    )
    fa_name = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        help_text="The Persian name of the market."
    )
    fa_base_asset = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        help_text="The Persian name of the base asset."
    )
    fa_quote_asset = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        help_text="The Persian name of the quote asset."
    )
    step_size = models.FloatField(  # Changed to FloatField to match API responses
        default=1.0,
        help_text="The step size for volume adjustments."
    )
    tick_size = models.FloatField(  # Changed to FloatField to match API responses
        default=1.0,
        help_text="The step size for price adjustments."
    )
    min_qty = models.FloatField(
        null=True,
        blank=True,
        help_text="The minimum quantity for trades."
    )
    min_notional = models.FloatField(
        null=True,
        blank=True,
        help_text="The minimum trade amount in the quote asset."
    )
    timestamp_created_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="The timestamp when the market was created."
    )
    # Adding a default for created_at and updated_at for better tracking
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.symbol

    def adjust_price(self, price: float) -> float:
        """
        Adjust the given price to match the tick size requirement for this market.
        Handles cases where tick_size might be None or 0.
        """
        if self.tick_size is not None and self.tick_size > 0:
            # Calculate the number of decimal places from tick_size
            # Example: tick_size = 0.001 -> 3 decimal places
            # If tick_size is 1, ndigits will be 0
            if self.tick_size < 1:
                ndigits = len(str(self.tick_size).split('.')[-1])
                adjusted_price = round(price / self.tick_size) * self.tick_size
                return round(adjusted_price, ndigits)  # Round to correct precision
            return round(price)  # If tick_size is 1 or more, round to nearest integer
        return float(price)  # Return original price if no tick_size or tick_size is 0

    def adjust_quantity(self, quantity: float) -> float:
        """
        Adjust the given quantity to be within the step size and allowable range for this market.
        Handles cases where step_size or min_qty might be None or 0.
        """
        if self.min_qty is not None and quantity < self.min_qty:
            quantity = self.min_qty  # Ensure quantity meets minimum requirement

        if self.step_size is not None and self.step_size > 0:
            # Calculate the number of decimal places from step_size
            if self.step_size < 1:
                ndigits = len(str(self.step_size).split('.')[-1])
                adjusted_quantity = round(quantity / self.step_size) * self.step_size
                return round(adjusted_quantity, ndigits)  # Round to correct precision
            return round(quantity)  # If step_size is 1 or more, round to nearest integer
        return float(quantity)  # Return original quantity if no step_size or step_size is 0

    def adjust_min_notional(self, amount: float) -> float:
        """
        Validate if the amount meets the minimum notional requirement.
        """
        if self.min_notional is not None and amount < self.min_notional:
            return self.min_notional
        return amount

    def adjust_min_qty(self, quantity: float) -> float:
        """
        Validate if the quantity meets the minimum quantity requirement.
        """
        if self.min_qty is not None and quantity < self.min_qty:
            return self.min_qty
        return quantity

    @classmethod
    def create_or_update_instance(cls, symbol_name: str, provider_name: str, **kwargs):
        """
        Create or update an instance of the Market model.
        """
        market, created = cls.objects.get_or_create(
            symbol=symbol_name,
            provider=provider_name,
            defaults=kwargs
        )

        if not created:
            # Update existing market instance with new data
            for key, value in kwargs.items():
                setattr(market, key, value)
            market.save()
            logger.info(f"Updated Market record for symbol: {symbol_name} from {provider_name}")
        else:
            logger.info(f"Created new Market record for symbol: {symbol_name} from {provider_name}")

        return market, created

    class Meta:
        # Add unique_together constraint to ensure unique (symbol, provider) pairs
        unique_together = ('symbol', 'provider')


class AdminSystemConfig(BaseModel):
    """
    Model to manage admin system configurations.
    """
    strategy_processor_batch_size = models.PositiveIntegerField(
        default=1,
        help_text="Batch size for strategy processor."
    )
    strategy_depth_orderbook = models.PositiveIntegerField(
        default=10,
        help_text="Depth of the order book for strategies."
    )
    wallex_tether_order_amount = models.PositiveIntegerField(
        default=20,
        help_text="Tether amount for ordering in Wallex."
    )
    put_same_order_base_in_every_order = models.BooleanField(
        default=True,
        help_text="Whether to put the same order base in every order."
    )
    kill_switch = models.BooleanField(
        default=False,
        help_text="Global kill switch to stop all strategies and tasks of system."
    )
    desired_balance_asset_in_usdt_tmn_market = models.CharField(
        choices=DesiredBalanceAsset.CHOICES,
        help_text="Desired balance asset in USDT/TMN market.",
        default=DesiredBalanceAsset.USDT,
        max_length=5,
    )

    class Meta:
        verbose_name = "Admin System Config"
        verbose_name_plural = "Admin System Configs"

    def __str__(self):
        return "Admin System Configurations"

    @classmethod
    def get_instance(cls):
        """
        Ensures only one instance of the model exists.
        Creates one if none exists.
        """
        instance, _ = cls.objects.get_or_create(id=1)
        return instance

    def get_value(self, key):
        """
        Retrieves the value of a specific configuration key.
        """
        return getattr(self, key, None)


class StrategyConfig(SoftDeleteModel, BaseModel):
    """
    Model to store configurations for various strategies.

    Attributes:
        strategy (str): The name of the strategy (e.g., StrategyMacdEmaCross").
        strategy_configs (dict): JSON field containing strategy-specific settings.
        market (ForeignKey): Foreign key referencing the `Market` model.
    """
    strategy = models.CharField(
        max_length=255,
        choices=StrategyEnum.choices(), # Use .choices()
        default=StrategyEnum.StrategyMacdEmaCross.name
    )
    store_client = models.ForeignKey(
        'StoreClient',
        default=None,
        on_delete=CASCADE,
        help_text="The store client associated with this strategy.",
    )
    need_historical_data = models.BooleanField(
        default=True,
    )
    strategy_configs = models.JSONField(
        default=dict,
        blank=True,
    )
    market = models.ForeignKey(
        Market,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="strategy_configs",
        help_text="The market associated with this strategy.",
    )
    sensitivity_percent = models.FloatField(
        default=0.01,
        validators=[
            MinValueValidator(0.000001, message="Value must be greater than 0."),
            MaxValueValidator(1.0, message="Value must not exceed 1."),
        ],
        help_text="A percentage of sensitivity for an order, must be between 0 (exclusive) and 1 (inclusive).",
    )
    initial_history_period_days = models.IntegerField(
        default=30,

    )
    resolution = models.CharField(
        choices=ResolutionEnum.choices(),
        help_text="The time resolution for historical data (e.g., 1 minute, 1 day).",
        default=ResolutionEnum.D.value,
        max_length=5,
    )
    state = models.PositiveSmallIntegerField(
        choices=StrategyState.choices(),
        default=StrategyState.STARTED.value,
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Indicates whether the strategy configuration is active."
    )

    def __str__(self):
        # Ensure market is not None before accessing its symbol
        market_info = self.market.symbol if self.market else "N/A"
        return f"{self.id} Configuration for {market_info} in strategy {self.strategy}"

    objects = SoftDeleteManager()  # Default manager (excludes soft-deleted items)
    all_objects = models.Manager()  # Includes all objects, even soft-deleted ones

    class Meta:
        verbose_name = "Strategy Configuration"
        verbose_name_plural = "Strategy Configurations"

    def soft_delete(self):
        """
        Soft delete: Marks the object as deleted.
        """
        super().soft_delete()

    def restore(self):
        """
        Restore a soft-deleted object.
        """
        super().restore()


    def get_config(self):
        """
        Returns a validated Pydantic schema instance for the strategy configuration.
        """
        from algo.strategies.schemas import get_strategy_schema
        
        schema_class = get_strategy_schema(self.strategy)
        return schema_class(**self.strategy_configs)

    @classmethod
    def update_state(cls, id: int , state: StrategyState):
        """
        Updates the state of the strategy with the given `id` and `state`.
        :param id: The ID of the StrategyConfig instance.
        :param state: The new StrategyState to set.
        :return: Number of updated rows.
        """
        # Ensure state is passed as its value
        return cls.objects.filter(
            id=id,
        ).update(state=state.value)